# -*- coding: utf-8 -*-
"""B22CI038_FEM_Assignment3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cMV9tPkfTOPbOMPUtMH3pb_wUhtYWZ5J

**Defining Gauss Points**
"""

import numpy as np
import matplotlib.pyplot as plt

# Gauss quadrature points and weights (4-point for quartic accuracy)
gauss_points = np.array([
    -np.sqrt((3 + 2*np.sqrt(6/5))/7),
    -np.sqrt((3 - 2*np.sqrt(6/5))/7),
    np.sqrt((3 - 2*np.sqrt(6/5))/7),
    np.sqrt((3 + 2*np.sqrt(6/5))/7)
])
gauss_weights = np.array([
    (18 - np.sqrt(30))/36,
    (18 + np.sqrt(30))/36,
    (18 + np.sqrt(30))/36,
    (18 - np.sqrt(30))/36
])

"""**Functions for taking User Inputs(For the current problems values are default)**"""

def get_user_inputs():
    """Get problem parameters from user"""
    print("=== Beam FEM Analysis (4th-Order Axial + Cubic Bending) ===")
    E = float(input("Young's modulus (Pa) [default: 2e11]: ") or 2e11)
    width = float(input("Beam width (m) [default: 0.125]: ") or 0.125)
    height = float(input("Beam height (m) [default: 0.25]: ") or 0.25)
    L_total = float(input("Beam length (m) [default: 10]: ") or 10)
    n_elements = int(input("Number of elements [default: 2]: ") or 2)
    q = float(input("Distributed load (N/m, downward negative) [default: -10000]: ") or -10000)
    P_axial = float(input("Axial point load at end (N, positive for tension) [default: 20000]: ") or 20000)

    # Calculate section properties
    A = width * height
    I = width * height**3 / 12

    return E, A, I, L_total, n_elements, q, P_axial

"""**Function for the Mesh generation(Discretization)**"""

def generate_mesh(L_total, n_elements):
    """Create nodes and elements with 4 nodes per element for quartic axial"""
    n_nodes = 3*n_elements + 1  # 4 nodes per element (3 interior points)

    nodes = np.zeros((n_nodes, 1))
    for i in range(n_nodes):
        nodes[i, 0] = i * (L_total / (3*n_elements))  # Evenly spaced nodes

    # Elements connectivity [n1, n2, n3, n4] (4 nodes per element)
    elements = np.array([[3*i, 3*i+1, 3*i+2, 3*i+3] for i in range(n_elements)])

    return nodes, elements

"""**Functions for defining Shape functions**"""

def quartic_lagrange_shape_functions(xi):
    """4th-order Lagrangian shape functions (4 nodes at ξ=-1,-1/3,1/3,1)"""
    N = np.array([
        (xi - 1/3)*(xi - 1/3)*(xi - 1)/((-1 - 1/3)*(-1 - 1/3)*(-1 - 1)),
        (xi + 1)*(xi - 1/3)*(xi - 1)/((-1/3 + 1)*(-1/3 - 1/3)*(-1/3 - 1)),
        (xi + 1)*(xi + 1/3)*(xi - 1)/((1/3 + 1)*(1/3 + 1/3)*(1/3 - 1)),
        (xi + 1)*(xi + 1/3)*(xi - 1/3)/((1 + 1)*(1 + 1/3)*(1 - 1/3))
    ])
    dN = np.array([
        ((xi - 1/3)*(xi - 1) + (xi - 1/3)*(xi - 1/3) + (xi - 1)*(xi - 1/3)) / ((-1 - 1/3)*(-1 - 1/3)*(-1 - 1)),
        ((xi - 1/3)*(xi - 1) + (xi + 1)*(xi - 1) + (xi + 1)*(xi - 1/3)) / ((-1/3 + 1)*(-1/3 - 1/3)*(-1/3 - 1)),
        ((xi + 1/3)*(xi - 1) + (xi + 1)*(xi - 1) + (xi + 1)*(xi + 1/3)) / ((1/3 + 1)*(1/3 + 1/3)*(1/3 - 1)),
        ((xi + 1/3)*(xi - 1/3) + (xi + 1)*(xi - 1/3) + (xi + 1)*(xi + 1/3)) / ((1 + 1)*(1 + 1/3)*(1 - 1/3))
    ])
    return N, dN

def cubic_hermite_shape_functions(xi, L):
    """Cubic Hermitian shape functions for bending"""
    N = np.array([
        0.25*(1-xi)**2*(2+xi),
        0.125*L*(1-xi)**2*(1+xi),
        0.25*(1+xi)**2*(2-xi),
        -0.125*L*(1+xi)**2*(1-xi)
    ])
    dN = np.array([
        0.75*(xi**2 - 1),
        0.125*L*(3*xi**2 - 2*xi - 1),
        -0.75*(xi**2 - 1),
        0.125*L*(3*xi**2 + 2*xi - 1)
    ])
    ddN = np.array([
        1.5*xi,
        0.25*L*(3*xi - 1),
        -1.5*xi,
        0.25*L*(3*xi + 1)
    ])
    dddN = np.array([
        1.5,
        0.75*L,
        -1.5,
        0.75*L
    ]) / (L/2)  # Third derivative needs Jacobian correction
    return N, dN, ddN, dddN



"""**Functions for Computing Stiffness matrix and Force vector for each element**"""

def compute_element_matrices(E, A, I, L, q):
    """Compute element matrices with 4th-order axial and cubic bending"""
    # Total DOFs: [u1, u2, u3, u4, v1, θ1, v2, θ2] (8 DOFs)
    ke = np.zeros((8,8))
    fe = np.zeros(8)

    for xi, w in zip(gauss_points, gauss_weights):
        # Axial (4th-order Lagrangian)
        N_axial, dN_axial = quartic_lagrange_shape_functions(xi)
        J_axial = L/2  # Jacobian

        # Bending (cubic Hermitian)
        N_bend, dN_bend, ddN_bend,_ = cubic_hermite_shape_functions(xi, L)
        J_bend = L/2

        # Axial stiffness
        B_axial = dN_axial / J_axial
        ke[:4,:4] += np.outer(B_axial, B_axial) * (E * A) * w * J_axial

        # Bending stiffness
        B_bend = ddN_bend / (J_bend**2)
        ke[4:,4:] += np.outer(B_bend, B_bend) * (E * I) * w * J_bend

        # Force vector (bending only)
        fe[4:] += N_bend * q * w * J_bend

    return ke, fe

"""**Functions to Assemble Loacal Matrices**"""

def assemble_global_system(nodes, elements, E, A, I, q):
    """Assemble global system with mixed DOFs"""
    n_nodes = len(nodes)
    n_elements = len(elements)
    # DOF ordering: all u's first, then all v's, then all θ's
    total_dofs = n_nodes + 2*(n_elements + 1)  # u's + (v and θ per element)
    K = np.zeros((total_dofs, total_dofs))
    F = np.zeros(total_dofs)

    for elem_idx, elem in enumerate(elements):
        start, mid1, mid2, end = elem
        L = nodes[end,0] - nodes[start,0]

        ke, fe = compute_element_matrices(E, A, I, L, q)

        # DOF mapping:
        # Axial: u_start, u_mid1, u_mid2, u_end -> global u indices
        # Bending: v_start, θ_start, v_end, θ_end -> global v and θ indices
        dofs = [
            start, mid1, mid2, end,  # Axial DOFs
            n_nodes + 2*elem_idx,      # v_start
            n_nodes + 2*elem_idx + 1,  # θ_start
            n_nodes + 2*(elem_idx+1),  # v_end
            n_nodes + 2*(elem_idx+1) + 1  # θ_end
        ]

        for i in range(8):
            F[dofs[i]] += fe[i]
            for j in range(8):
                K[dofs[i], dofs[j]] += ke[i,j]

    return K, F

"""**Function for Applying Boundary Conditions**"""

def apply_boundary_conditions(nodes, K, F, P_axial, n_elements):
    """Apply fixed support and axial load"""
    n_nodes = len(nodes)
    fixed_dofs = [
        0,          # u at first node (axial)
        n_nodes,    # v at first node (vertical)
        n_nodes + 1 # θ at first node (rotation)
    ]

    # Apply axial load at last node
    F[n_nodes - 1] += P_axial  # Last u DOF

    # Get free DOFs
    all_dofs = np.arange(K.shape[0])
    free_dofs = np.setdiff1d(all_dofs, fixed_dofs)

    return K[free_dofs, :][:, free_dofs], F[free_dofs], free_dofs

"""Functions for Solving and Reconstructing the Diplacement vector"""

def solve_and_reconstruct(K_reduced, F_reduced, free_dofs, total_dofs):
    """Solve reduced system"""
    q_reduced = np.linalg.solve(K_reduced, F_reduced)
    q_full = np.zeros(total_dofs)
    q_full[free_dofs] = q_reduced
    return q_full

"""Functions to Compute Results"""

def compute_results(elements, nodes, q_full, E, A, I, n_elements):
    """Compute stresses, moments and shear forces"""
    results = []
    n_nodes = len(nodes)

    for elem_idx, elem in enumerate(elements):
        start, mid1, mid2, end = elem
        L = nodes[end,0] - nodes[start,0]

        # Get element DOFs [u1, u2, u3, u4, v1, θ1, v2, θ2]
        dofs = [
            start, mid1, mid2, end,
            n_nodes + 2*elem_idx,
            n_nodes + 2*elem_idx + 1,
            n_nodes + 2*(elem_idx+1),
            n_nodes + 2*(elem_idx+1) + 1
        ]
        q_e = q_full[dofs]

        elem_results = {
            'element': elem_idx,
            'length': L,
            'gauss_points': []
        }

        for xi in gauss_points:
            N_axial, dN_axial = quartic_lagrange_shape_functions(xi)
            N_bend, dN_bend, ddN_bend,dddN_bend = cubic_hermite_shape_functions(xi, L)
            x = nodes[start,0] + (xi + 1)/2 * L

            # Axial calculations
            strain_axial = np.dot(dN_axial/(L/2), q_e[:4])
            stress_axial = E * strain_axial

            # Bending calculations
            curvature = np.dot(ddN_bend/((L/2)**2), q_e[4:])
            moment = E * I * curvature

            # Shear calculations
            shear_strain = np.dot(dN_bend/(L/2), q_e[4:])
            shear_force = E * I * np.dot(dddN_bend/((L/2)**3), q_e[4:])

            elem_results['gauss_points'].append({
                'x': x,

                'strain_axial': strain_axial,
                'stress_axial': stress_axial,
                'moment': moment,
                'shear_force': shear_force,
                'curvature': curvature
            })

        results.append(elem_results)

    return results

"""FUnctions to print the required Details"""

def print_detailed_results(results):
    """Print detailed results for each element and Gauss point"""
    print("\n=== DETAILED RESULTS AT GAUSS POINTS ===")
    for elem in results:
        print(f"\nElement {elem['element']+1} (Length: {elem['length']:.3f} m)")
        print("Gauss Point | Position (m) | Axial Strain | Axial Stress (Pa) | Moment (Nm) | Shear Force (N) | Curvature (1/m)")
        print("-"*110)

        for i, gp in enumerate(elem['gauss_points']):
            print(f"{i+1:11d} | {gp['x']:11.4f} | {gp['strain_axial']:12.4e} | {gp['stress_axial']:17.2f} | {gp['moment']:10.2f} | {gp['shear_force']:14.2f} | {gp['curvature']:14.4e}")

def print_summary(nodes, q_full, results, n_elements):
    """Print summary results"""
    n_nodes = len(nodes)
    print("\n=== NODAL DISPLACEMENTS ===")
    print("Node   X(m)     u(m)         v(m)         θ(rad)")

    for i in range(n_nodes):
        u = q_full[i]
        if i % 3 == 0:  # Only corner nodes have v and θ
            elem_idx = i//3
            v = q_full[n_nodes + 2*elem_idx]
            θ = q_full[n_nodes + 2*elem_idx + 1]
            print(f"{i:4d} {nodes[i,0]:6.2f} {u:12.4e} {v:12.4e} {θ:12.4e}")
        else:
            print(f"{i:4d} {nodes[i,0]:6.2f} {u:12.4e} {'-':>12s} {'-':>12s}")

    print("\n=== MAXIMUM VALUES ===")
    max_u = np.max(np.abs(q_full[:n_nodes]))
    max_v = np.max(np.abs(q_full[n_nodes::2]))

    # Fix: Convert generator expressions to lists first
    all_stresses = [gp['stress_axial'] for elem in results for gp in elem['gauss_points']]
    all_moments = [gp['moment'] for elem in results for gp in elem['gauss_points']]

    max_stress = np.max(np.abs(all_stresses))
    max_moment = np.max(np.abs(all_moments))

    print(f"Maximum axial displacement: {max_u:.4e} m")
    print(f"Maximum vertical displacement: {max_v:.4e} m")
    print(f"Maximum axial stress: {max_stress:.2f} Pa")
    print(f"Maximum bending moment: {max_moment:.2f} Nm")

"""Functions for Ploting the results"""

def plot_results(nodes, q_full, results, n_elements):
    """Plot deformation and results"""
    plt.figure(figsize=(15,5))

    # Deformed shape
    plt.subplot(1,3,1)
    x = nodes[:,0]
    n_nodes = len(nodes)
    v_dofs = range(n_nodes, n_nodes + 2*(n_elements + 1), 2)
    v = q_full[v_dofs]
    plt.plot(x[::3], np.zeros_like(x[::3]), 'k--', label='Undeformed')
    plt.plot(x[::3], v*1000, 'r-o', label='Deformed (x1000)')
    plt.title("Deformed Shape")
    plt.xlabel("Position (m)")
    plt.ylabel("Displacement (mm)")
    plt.legend()
    plt.grid(True)

    # Bending moment
    plt.subplot(1,3,2)
    for elem in results:
        x = [gp['x'] for gp in elem['gauss_points']]
        moment = [gp['moment'] for gp in elem['gauss_points']]
        plt.plot(x, moment, 'b-o')
    plt.title("Bending Moment")
    plt.xlabel("Position (m)")
    plt.ylabel("Moment (Nm)")
    plt.grid(True)

    # Axial stress
    plt.subplot(1,3,3)
    for elem in results:
        x = [gp['x'] for gp in elem['gauss_points']]
        stress = [gp['stress_axial'] for gp in elem['gauss_points']]
        plt.plot(x, stress, 'g-o')
    plt.title("Axial Stress")
    plt.xlabel("Position (m)")
    plt.ylabel("Stress (Pa)")
    plt.grid(True)

    plt.tight_layout()
    plt.show()

def plot_stress_distribution(results):
    """Plot stress distribution at Gauss points"""
    plt.figure(figsize=(15, 5))

    # Stress distribution
    plt.subplot(1, 3, 1)
    for elem in results:
        x = [gp['x'] for gp in elem['gauss_points']]
        stress = [gp['stress_axial'] for gp in elem['gauss_points']]
        plt.plot(x, stress, 'bo-', label=f'Element {elem["element"]+1}')
    plt.title("Axial Stress at Gauss Points")
    plt.xlabel("Position (m)")
    plt.ylabel("Stress (Pa)")
    plt.grid(True)
    plt.legend()

    # Moment distribution
    plt.subplot(1, 3, 2)
    for elem in results:
        x = [gp['x'] for gp in elem['gauss_points']]
        moment = [gp['moment'] for gp in elem['gauss_points']]
        plt.plot(x, moment, 'ro-', label=f'Element {elem["element"]+1}')
    plt.title("Bending Moment at Gauss Points")
    plt.xlabel("Position (m)")
    plt.ylabel("Moment (Nm)")
    plt.grid(True)
    plt.legend()

    # Shear distribution
    plt.subplot(1, 3, 3)
    for elem in results:
        x = [gp['x'] for gp in elem['gauss_points']]
        shear = [gp['shear_force'] for gp in elem['gauss_points']]
        plt.plot(x, shear, 'go-', label=f'Element {elem["element"]+1}')
    plt.title("Shear Force at Gauss Points")
    plt.xlabel("Position (m)")
    plt.ylabel("Shear Force (N)")
    plt.grid(True)
    plt.legend()

    plt.tight_layout()
    plt.show()

"""Functions for Reaction Forces"""

# === Compute Reaction Forces ===
def compute_reactions(K_full, F_full, q_full, fixed_dofs):
    R = K_full @ q_full - F_full
    print("\n=== REACTION FORCES AT FIXED DOFs ===")
    for dof in fixed_dofs:
        print(f"DOF {dof}: {R[dof]:.2f} N")
    return R[fixed_dofs]

"""Inputs"""

# Number of Elements=2

if __name__ == "__main__":
    E, A, I, L_total, n_elements, q, P_axial = get_user_inputs()
    nodes, elements = generate_mesh(L_total, n_elements)
    K_global, F_global = assemble_global_system(nodes, elements, E, A, I, q)
    K_reduced, F_reduced, free_dofs = apply_boundary_conditions(nodes, K_global, F_global, P_axial, n_elements)
    q_full = solve_and_reconstruct(K_reduced, F_reduced, free_dofs, K_global.shape[0])
    results = compute_results(elements, nodes, q_full, E, A, I, n_elements)
    fixed_dofs = [0, len(nodes), len(nodes) + 1]  # u, v, θ at node 0
    compute_reactions(K_global, F_global, q_full, fixed_dofs)
    print_summary(nodes, q_full, results, n_elements)
    print_detailed_results(results)

    plot_results(nodes, q_full, results, n_elements)
    plot_stress_distribution(results)

# Number of Elements=3

if __name__ == "__main__":
    E, A, I, L_total, n_elements, q, P_axial = get_user_inputs()
    nodes, elements = generate_mesh(L_total, n_elements)
    K_global, F_global = assemble_global_system(nodes, elements, E, A, I, q)
    K_reduced, F_reduced, free_dofs = apply_boundary_conditions(nodes, K_global, F_global, P_axial, n_elements)
    q_full = solve_and_reconstruct(K_reduced, F_reduced, free_dofs, K_global.shape[0])
    results = compute_results(elements, nodes, q_full, E, A, I, n_elements)
    fixed_dofs = [0, len(nodes), len(nodes) + 1]  # u, v, θ at node 0
    compute_reactions(K_global, F_global, q_full, fixed_dofs)
    print_summary(nodes, q_full, results, n_elements)
    print_detailed_results(results)

    plot_results(nodes, q_full, results, n_elements)
    plot_stress_distribution(results)